1) LINUX COMMANDS
*****************

AIM: To study and execute Linux Commands
COMMANDS:
	1. man <command>
		used to display the help manual
	
	2. touch <filename>
		used to create an blank file named <filename>
	
	3. cat <filename>
		used to print contents of the file named <filename>
	
	4. mkdir <dirname>
		used to create a directory called <dirname>
	
	5. rm <filename>
		used to remove a file called <filename>
	
	6. rmdir <dirname>
		used to remove a directory called <dirname>
	
	7. pwd
		used to display the current working directory
		
	8. ls
		used to list all files and directories in current working directory
		
	9. ls <dirname>
		used to list all files and directories in <dirname> direectory
	
	10. cd <dirname>
		used to switch the current working directory to <dirname>
	
	11. cp <sourceFile> <destinationFile>
		used to copy the filecontents from <sourceFile> to <destinationFile>
	
	12. mv <sourceFile> <destinationFile>
		used to move the filecontents from <sourceFile> to <destinationFile>
		
	13. echo "" | bc
		used to perfrom basic calculations
		
	14. head <filename>
		prints first 10 lines from file <filename>
	
	15. tail <filename>
		prints last 10 lines from file <filename>
		
	16. wc <filename>
		prints the character, word and line count of the file <filename>
	
	17. rev <filename>
		reverses the content of the file <filename> line-by-line
	
	18. whoami
		prints the details of the current user
	
	19. echo ""
		prints the content inside the quotes
	
	20. date
		prints the current date and time

2. SHELL PROGRAMMING
********************

AIM: To develop a simple calculator
PROGRAM:
	#!/bin/bash

	read -p "Enter a Integer: " a
	read -p "Enter another Integer: " b
	
	echo "1. Addition"
	echo "2. Subraction"
	echo "3. Multiplication"
	echo "4. Division"
	echo "5. Modulus"
	read -p "Enter your choice: " ch

	case $ch in
	1)
		res=$(( a+b ))
		echo "A + B = $res";;
	2)
		res=$(( a-b ))
		echo "A - B = $res";;
	3)
		res=$(( a*b ))
		echo "A * B = $res";;
	4)
		res=$(( a/b ))
		echo "A / B = $res";;
	5)
		res=$(( a%b ))
		echo "A % B = $res";;
	esac
	
AIM: To develop a program for Pattern Generation
PROGRAM:
	#!/bin/bash

	echo "Welcome to Pattern Generator"
	echo "****************************"
	echo
	read -p "Enter number of lines: " n
	echo
	echo "1. Simple Triangle"
	echo "2. Simple Number Triangle"
	echo "3. Right Triangle"
	echo "4. Triangle"
	echo "5. Diamond"
	read -p "Enter your choice: " ch
	echo
	echo
	
	case $ch in
	1)
		for((i=0; i<n; i++)) do
			for((j=0; j<i; j++)) do
				echo -n "* "
			done
			echo
		done;;
	2)
		for((i=0; i<n; i++)) do
			for((j=0; j<i; j++)) do
				echo -n "$j "
			done
			echo
		done;;
	3)
		for((i=0; i<n; i++)) do
			for((j=n-i; j>0; j--)) do
				echo -n "  "
			done
			for((j=0; j<i; j++)) do
				echo -n "* "
			done
			echo
		done;;
	4)
		for((i=0; i<n; i++)) do
			for((j=n-i; j>0; j--)) do
				echo -n "  "
			done
			for((j=0; j<i; j++)) do
				echo -n "* "
			done
			for((j=0; j<i-1; j++)) do
				echo -n "* "
			done
			echo
		done;;
	5)
		for((i=0; i<n; i++)) do
			for((j=n-i; j>0; j--)) do
				echo -n "  "
			done
			for((j=0; j<i; j++)) do
				echo -n "* "
			done
			for((j=0; j<i-1; j++)) do
				echo -n "* "
			done		
			echo
		done
		for((i=n-2; i>0; i--)) do
			for((j=n-i; j>0; j--)) do
				echo -n "  "
			done
			for((j=0; j<i; j++)) do
				echo -n "* "
			done
			for((j=0; j<i-1; j++)) do
				echo -n "* "
			done
			echo
		done;;
	esac


AIM: To develop a program to Generate Fibonacci Series
Program:
	#!/bin/bash
	
	read -p "Enter an Integer: " n
	
	a=0
	b=1
	echo -n "Fibonacci Series: "
	for((i=0; i<n; i++)) do
		echo -n "$a "
		c=$((a+b))
		a=$b
		b=$c
	done
	echo


3. FORK SYSTEM CALL
*******************

AIM: To create a new child process using fork system call
PROCEDURE:
	STEP 1:	Create a blank text file named fork.c and type in the following
		#include <stdio.h>
		#include <unistd.h>
		
		int main() {
			pid_t pid = fork();
			
			if(pid < 0) {
				printf("Fork failed\n");
				return 1;
			} 
			else if (pid == 0)
				printf("Hello from child process with PID: %d\n", getpid());
			else
				printf("Hello from parent process with PID: %d\n", getpid());
			return 0;
		}
	STEP 2: Compile the created .c file with gcc compiler and store the compiled binary into a.out
		gcc fork.c -o a.out
	STEP 3: Execute the compiled Binary from the Terminal
		./a.out

4. WAIT SYSTEM CALL
*******************

AIM: To block a parent until child completes using wait system call
PROCEDURE:
	STEP 1: Create a blank text file calles wait.c and type in the following
		#include <stdio.h>
		#include <unistd.h>
		#include <sys/wait.h>
	
		int main() {
	  	pid_t pid = fork();
	  
		  if(pid < 0) {
		    printf("Fork Failed");
		    return 1;
		  }
		  else if(pid == 0) {
		    printf("Child with Odd Numbers: ");
		    for(int i = 1; i < 10; i=i+2)
		      printf("%d ", i);
		    printf("Child ends\n");
		  }
		  else {
		    wait(NULL);
		    printf("Parent with Even Numbers: ");
		    for(int i = 0; i < 10; i=i+2)
		      printf("%d ", i);
		    printf("Parent ends\n");
		  }
		  return 0;
		}
	STEP 2: Compile the created .c file with gcc compiler and store the compiled binary in a.out
		gcc wait.c -o a.out
	STEP 3: Execute the compiled Binary from the Terminal
		./a.out

5. EXECL SYSTEM CALL
*******************

AIM: To load an executable program in a child process using execl system call
PROCEDURE:
	STEP 1: Create a blank text file calles execl.c and type in the following
		#include <stdio.h>
		#include <unistd.h>
		#include <sys/wait.h>

		int main() {
		  pid_t pid = fork();
  
		  if(pid < 0) {
    		printf("Fork Failed\n");
		    return 1;
  		}
  		else if(pid == 0) {
    		printf("Child Process: ");
    		execl("/bin/date", "date", NULL);
    		return 0;
  		}
  		else {
    		wait(NULL);
    		printf("Child Terminated\n");
    		return 0;
  		}
		}
	STEP 2: Compile the created .c file with gcc compiler and store the compiled binary in a.out
		gcc execl.c -o a.out
	STEP 3: Execute the compiled Binary from the Terminal
		./a.out

6. STAT SYSTEM CALL
*******************

AIM: To display file status using stat system call
PROCEDURE:
	STEP 1: Create a blank text file calles stat.c and type in the following
		#include <stdio.h>
		#include <unistd.h>
		#include <sys/stat.h>
		#include <time.h>
		#include <stdlib.h>
		#include <string.h>
		#include <errno.h>

		int main(int argc, char *argv[]) {
    	struct stat file;

	    if (argc != 2) {
        printf("Usage: ./a.out <filename>\n");
        return -1;
	    }

	    if (stat(argv[1], &file) == -1) {
        perror("Error getting file info");
        return -1;
	    }

	    printf("User ID: %d\n", file.st_uid);
	    printf("Group ID: %d\n", file.st_gid);
	    printf("Block Size: %ld\n", file.st_blksize);
	    printf("Blocks Allocated: %ld\n", file.st_blocks);
	    printf("Inode No.: %lu\n", file.st_ino);
	    printf("Last Accessed: %s", ctime(&file.st_atime));
	    printf("Last Modified: %s", ctime(&file.st_mtime));
	    printf("File Size: %ld bytes\n", file.st_size);
	    printf("No. of Links: %ld\n", file.st_nlink);
	
	    // Permissions
	    printf("Permissions: ");
	    printf((S_ISDIR(file.st_mode)) ? "d" : "-");
	    printf((file.st_mode & S_IRUSR) ? "r" : "-");
	    printf((file.st_mode & S_IWUSR) ? "w" : "-");
	    printf((file.st_mode & S_IXUSR) ? "x" : "-");
	    printf((file.st_mode & S_IRGRP) ? "r" : "-");
	    printf((file.st_mode & S_IWGRP) ? "w" : "-");
	    printf((file.st_mode & S_IXGRP) ? "x" : "-");
	    printf((file.st_mode & S_IROTH) ? "r" : "-");
	    printf((file.st_mode & S_IWOTH) ? "w" : "-");
	    printf((file.st_mode & S_IXOTH) ? "x" : "-");
	    printf("\n");
	
	    // File type
	    if (S_ISREG(file.st_mode))
	        printf("File Type: Regular File\n");
	    else if (S_ISDIR(file.st_mode))
	        printf("File Type: Directory\n");
	    else
	        printf("File Type: Other\n");
	
	    return 0;
		}
	STEP 2: Compile the created .c file with gcc compiler and store the compiled binary in a.out
		gcc stat.c -o a.out
	STEP 3: Execute the compiled Binary from the Terminal
		./a.out
		
