1) LINUX COMMANDS
*****************

AIM: To study and execute Linux Commands
COMMANDS:
	1. man <command>
		used to display the help manual
	
	2. touch <filename>
		used to create an blank file named <filename>
	
	3. cat <filename>
		used to print contents of the file named <filename>
	
	4. mkdir <dirname>
		used to create a directory called <dirname>
	
	5. rm <filename>
		used to remove a file called <filename>
	
	6. rmdir <dirname>
		used to remove a directory called <dirname>
	
	7. pwd
		used to display the current working directory
		
	8. ls
		used to list all files and directories in current working directory
		
	9. ls <dirname>
		used to list all files and directories in <dirname> direectory
	
	10. cd <dirname>
		used to switch the current working directory to <dirname>
	
	11. cp <sourceFile> <destinationFile>
		used to copy the filecontents from <sourceFile> to <destinationFile>
	
	12. mv <sourceFile> <destinationFile>
		used to move the filecontents from <sourceFile> to <destinationFile>
		
	13. echo "" | bc
		used to perfrom basic calculations
		
	14. head <filename>
		prints first 10 lines from file <filename>
	
	15. tail <filename>
		prints last 10 lines from file <filename>
		
	16. wc <filename>
		prints the character, word and line count of the file <filename>
	
	17. rev <filename>
		reverses the content of the file <filename> line-by-line
	
	18. whoami
		prints the details of the current user
	
	19. echo ""
		prints the content inside the quotes
	
	20. date
		prints the current date and time

2. SHELL PROGRAMMING
********************

AIM: To develop a simple calculator
PROGRAM:
	#!/bin/bash

	read -p "Enter a Integer: " a
	read -p "Enter another Integer: " b
	
	echo "1. Addition"
	echo "2. Subraction"
	echo "3. Multiplication"
	echo "4. Division"
	echo "5. Modulus"
	read -p "Enter your choice: " ch

	case $ch in
	1)
		res=$(( a+b ))
		echo "A + B = $res";;
	2)
		res=$(( a-b ))
		echo "A - B = $res";;
	3)
		res=$(( a*b ))
		echo "A * B = $res";;
	4)
		res=$(( a/b ))
		echo "A / B = $res";;
	5)
		res=$(( a%b ))
		echo "A % B = $res";;
	esac
	
AIM: To develop a program for Pattern Generation
PROGRAM:
	#!/bin/bash

	echo "Welcome to Pattern Generator"
	echo "****************************"
	echo
	read -p "Enter number of lines: " n
	echo
	echo "1. Simple Triangle"
	echo "2. Simple Number Triangle"
	echo "3. Right Triangle"
	echo "4. Triangle"
	echo "5. Diamond"
	read -p "Enter your choice: " ch
	echo
	echo
	
	case $ch in
	1)
		for((i=0; i<n; i++)) do
			for((j=0; j<i; j++)) do
				echo -n "* "
			done
			echo
		done;;
	2)
		for((i=0; i<n; i++)) do
			for((j=0; j<i; j++)) do
				echo -n "$j "
			done
			echo
		done;;
	3)
		for((i=0; i<n; i++)) do
			for((j=n-i; j>0; j--)) do
				echo -n "  "
			done
			for((j=0; j<i; j++)) do
				echo -n "* "
			done
			echo
		done;;
	4)
		for((i=0; i<n; i++)) do
			for((j=n-i; j>0; j--)) do
				echo -n "  "
			done
			for((j=0; j<i; j++)) do
				echo -n "* "
			done
			for((j=0; j<i-1; j++)) do
				echo -n "* "
			done
			echo
		done;;
	5)
		for((i=0; i<n; i++)) do
			for((j=n-i; j>0; j--)) do
				echo -n "  "
			done
			for((j=0; j<i; j++)) do
				echo -n "* "
			done
			for((j=0; j<i-1; j++)) do
				echo -n "* "
			done		
			echo
		done
		for((i=n-2; i>0; i--)) do
			for((j=n-i; j>0; j--)) do
				echo -n "  "
			done
			for((j=0; j<i; j++)) do
				echo -n "* "
			done
			for((j=0; j<i-1; j++)) do
				echo -n "* "
			done
			echo
		done;;
	esac


AIM: To develop a program to Generate Fibonacci Series
Program:
	#!/bin/bash
	
	read -p "Enter an Integer: " n
	
	a=0
	b=1
	echo -n "Fibonacci Series: "
	for((i=0; i<n; i++)) do
		echo -n "$a "
		c=$((a+b))
		a=$b
		b=$c
	done
	echo


3. FORK SYSTEM CALL
*******************

AIM: To create a new child process using fork system call
PROCEDURE:
	STEP 1:	Create a blank text file named fork.c and type in the following
		#include <stdio.h>
		#include <unistd.h>
		
		int main() {
			pid_t pid = fork();
			
			if(pid < 0) {
				printf("Fork failed\n");
				return 1;
			} 
			else if (pid == 0)
				printf("Hello from child process with PID: %d\n", getpid());
			else
				printf("Hello from parent process with PID: %d\n", getpid());
			return 0;
		}
	STEP 2: Compile the created .c file with gcc compiler and store the compiled binary into a.out
		gcc fork.c -o a.out
	STEP 3: Execute the compiled Binary from the Terminal
		./a.out

4. WAIT SYSTEM CALL
*******************

AIM: To block a parent until child completes using wait system call
PROCEDURE:
	STEP 1: Create a blank text file calles wait.c and type in the following
		#include <stdio.h>
		#include <unistd.h>
		#include <sys/wait.h>
	
		int main() {
	  	pid_t pid = fork();
	  
		  if(pid < 0) {
		    printf("Fork Failed");
		    return 1;
		  }
		  else if(pid == 0) {
		    printf("Child with Odd Numbers: ");
		    for(int i = 1; i < 10; i=i+2)
		      printf("%d ", i);
		    printf("Child ends\n");
		  }
		  else {
		    wait(NULL);
		    printf("Parent with Even Numbers: ");
		    for(int i = 0; i < 10; i=i+2)
		      printf("%d ", i);
		    printf("Parent ends\n");
		  }
		  return 0;
		}
	STEP 2: Compile the created .c file with gcc compiler and store the compiled binary in a.out
		gcc wait.c -o a.out
	STEP 3: Execute the compiled Binary from the Terminal
		./a.out

5. EXECL SYSTEM CALL
*******************

AIM: To load an executable program in a child process using execl system call
PROCEDURE:
	STEP 1: Create a blank text file calles execl.c and type in the following
		#include <stdio.h>
		#include <unistd.h>
		#include <sys/wait.h>

		int main() {
		  pid_t pid = fork();
  
		  if(pid < 0) {
    		printf("Fork Failed\n");
		    return 1;
  		}
  		else if(pid == 0) {
    		printf("Child Process: ");
    		execl("/bin/date", "date", NULL);
    		return 0;
  		}
  		else {
    		wait(NULL);
    		printf("Child Terminated\n");
    		return 0;
  		}
		}
	STEP 2: Compile the created .c file with gcc compiler and store the compiled binary in a.out
		gcc execl.c -o a.out
	STEP 3: Execute the compiled Binary from the Terminal
		./a.out

6. STAT SYSTEM CALL
*******************

AIM: To display file status using stat system call
PROCEDURE:
	STEP 1: Create a blank text file calles stat.c and type in the following
		#include <stdio.h>
		#include <unistd.h>
		#include <sys/stat.h>
		#include <time.h>
		#include <stdlib.h>
		#include <string.h>
		#include <errno.h>

		int main(int argc, char *argv[]) {
    	struct stat file;

	    if (argc != 2) {
        printf("Usage: ./a.out <filename>\n");
        return -1;
	    }

	    if (stat(argv[1], &file) == -1) {
        perror("Error getting file info");
        return -1;
	    }

	    printf("User ID: %d\n", file.st_uid);
	    printf("Group ID: %d\n", file.st_gid);
	    printf("Block Size: %ld\n", file.st_blksize);
	    printf("Blocks Allocated: %ld\n", file.st_blocks);
	    printf("Inode No.: %lu\n", file.st_ino);
	    printf("Last Accessed: %s", ctime(&file.st_atime));
	    printf("Last Modified: %s", ctime(&file.st_mtime));
	    printf("File Size: %ld bytes\n", file.st_size);
	    printf("No. of Links: %ld\n", file.st_nlink);
	
	    // Permissions
	    printf("Permissions: ");
	    printf((S_ISDIR(file.st_mode)) ? "d" : "-");
	    printf((file.st_mode & S_IRUSR) ? "r" : "-");
	    printf((file.st_mode & S_IWUSR) ? "w" : "-");
	    printf((file.st_mode & S_IXUSR) ? "x" : "-");
	    printf((file.st_mode & S_IRGRP) ? "r" : "-");
	    printf((file.st_mode & S_IWGRP) ? "w" : "-");
	    printf((file.st_mode & S_IXGRP) ? "x" : "-");
	    printf((file.st_mode & S_IROTH) ? "r" : "-");
	    printf((file.st_mode & S_IWOTH) ? "w" : "-");
	    printf((file.st_mode & S_IXOTH) ? "x" : "-");
	    printf("\n");
	
	    // File type
	    if (S_ISREG(file.st_mode))
	        printf("File Type: Regular File\n");
	    else if (S_ISDIR(file.st_mode))
	        printf("File Type: Directory\n");
	    else
	        printf("File Type: Other\n");
	
	    return 0;
		}
	STEP 2: Compile the created .c file with gcc compiler and store the compiled binary in a.out
		gcc stat.c -o a.out
	STEP 3: Execute the compiled Binary from the Terminal
		./a.out
		
7. INTERPROCESS COMMUNICATION
*****************************

AIM: To Implement IPC using popen() and pclose()
PROCEDURE:
	STEP 1: Create a blank text file calles IPC_1.c and type in the following
		#include <stdio.h>
		#include <string.h>

		int main() {
  		FILE *rd;
  		char buffer[50];
		  sprintf(buffer, "name first");

  		rd = popen("wc -c", "w");
  		if (rd == NULL) {
    		perror("popen failed");
    		return 1;
  		}

		  fwrite(buffer, sizeof(char), strlen(buffer), rd);
  		pclose(rd);

		  return 0;
		}
	STEP 2: Compile the created .c file with gcc compiler and store the compiled binary in a.out
		gcc IPC_1.c -o a.out
	STEP 3: Execute the compiled Binary from the Terminal
		./a.out
		
		
AIM: To Implement IPC using pipe()
PROCEDURE:
	STEP 1: Create a blank text file calles IPC_2.c and type in the following
		#include <stdio.h>
		#include <unistd.h>
		#include <sys/types.h>
		#include <sys/wait.h>

		int main() {
  		int fd[2], n;
  		char buffer[100];
  		pid_t p;
  
		  pipe(fd);
		  p = fork();
	  
		  if (p < 0) {
		    printf("Fork failed\n");
		    return 1;
		  } 
		  else if (p > 0) {
		    printf("Parent passing value to child\n");
		    write(fd[1], "hello\n", 6);
		    close(fd[1]);
		    wait(NULL);
		  } 
		  else {
		    printf("Child receiving value from parent: ");
		    fflush(stdout);
		    close(fd[1]);
		    n = read(fd[0], buffer, 100);
		    write(1, buffer, n);
		  }
		  return 0;
		}
	STEP 2: Compile the created .c file with gcc compiler and store the compiled binary in a.out
		gcc IPC_2.c -o a.out
	STEP 3: Execute the compiled Binary from the Terminal
		./a.out
		
AIM: To Implement IPC using fifo pipe()
PROCEDURE:
	STEP 1: Create a blank text file calles IPC_sender.c and type in the following
		// sender.c
		#include <stdio.h>
		#include <fcntl.h>
		#include <unistd.h>
		#include <sys/stat.h>

		int main() {
		    const char *fifo = "/tmp/myfifo";
		    mkfifo(fifo, 0666); // Create the named pipe (only once)
		
		    int fd = open(fifo, O_WRONLY); // Open for writing
		    char message[] = "Hello from sender!\n";
		
		    write(fd, message, sizeof(message));
		    close(fd);

		    return 0;
		}
	STEP 2: Create another blank text file calles IPC_reciever.c and type in the following
		// receiver.c
		#include <stdio.h>
		#include <fcntl.h>
		#include <unistd.h>
		#include <sys/stat.h>

		int main() {
		    const char *fifo = "/tmp/myfifo";
		    mkfifo(fifo, 0666); // Create the named pipe (only once)

		    int fd = open(fifo, O_RDONLY); // Open for reading
		    char buffer[100];

		    read(fd, buffer, sizeof(buffer));
		    printf("Received: %s", buffer);
		    close(fd);

		    return 0;
		}
	STEP 3: Compile the created .c files with gcc compiler and store the compiled binary in a_sender.out and a_reciever.out
		gcc IPC_sender.c -o a_sender.out
		gcc IPC_reciever.c -o a_reciever.out
	STEP 4: Execute the compiled Binary from the Terminal
		./a_sender.out
		./a_reciever.out
		
8. CREATION OF ZOMBIE AND ORPHAN PROCESS
****************************************

AIM: To demonstrate the creation of Zombie and orphan process using C
PROCEDURE:
	STEP 1: Create a blank text file calles zombie.c and type in the following
		// zombie.c
		#include <stdio.h>
		#include <unistd.h>

		int main() {
		  pid_t t = fork();
		  
		  if (t < 0) {
		    printf("Fork failed");
		    return 1;
		  }
		  else if (t == 0) {
		    printf("Child having PID: %d\n", getpid());
		    return 0;
		  }
		  else {
		    printf("Parent having id %d\n", getpid());
		    sleep(5);
		  }
		}
	STEP 2: Compile the created .c files with gcc compiler and store the compiled binary in a_sender.out and a_reciever.out
		gcc zombie.c -o a.out
	STEP 3: Execute the compiled Binary from the Terminal
		./a.out
	STEP 4: Create another blank text file calles orphan.c and type in the following
		// orphan.c
		#include <stdio.h>
		#include <unistd.h>
		#include <sys/types.h>

		int main() {
		  pid_t pid = fork();
	  
		  if (pid < 0) {
		    printf("Fork Failed");
		    return 1;
		  }
		  else if (pid > 0) {
		    printf("I'm a Parent with PID: %d\t", getpid());
		    printf("My Child has a PID: %d\n", pid);
		  }
		  else {
		    sleep(5);
		    printf("I'm a Child with PID: %d\t", getpid());
		    printf("My Parent has PID: %d\n", getppid());
		  }
		  return 0;
		}
	STEP 5: Compile the created .c files with gcc compiler and store the compiled binary in a_sender.out and a_reciever.out
		gcc orphan.c -o a.out
	STEP 6: Execute the compiled Binary from the Terminal
		./a.out
		
9. IMPLEMENTATION OF THREADING
******************************

AIM: To write a c program to implement the concept of Threads
PROCEDURE:
	STEP 1: Create a blank text file named threading.c and type in the following
		#include <stdio.h>
		#include <unistd.h>
		#include <pthread.h>
		#include <stdlib.h>

		void *thread_function(void *args);
		int i, n, j;

		int main() {
    	char *m = "5";
    	pthread_t a;
    	void *result;

    	pthread_create(&a, NULL, thread_function, m);
    	pthread_join(a, &result);
    	printf("Thread created and joined\n");

    	for(j = 20; j < 25; j++) {
        printf("%d\t", j);
        sleep(1);
    	}

    	printf("\nThread returned %s\n", (char *)result);
    	return 0;
		}

		void *thread_function(void *args) {
    	int sum = 0;
    	n = atoi((char *)args);
    	for(i = 0; i < n; i++) {
        printf("%d\t", i);
        sleep(1);
    	}
    	printf("\n");
    	pthread_exit("Done");
		}
	STEP 2: Compile the created .c files with gcc compiler and store the compiled binary in a_sender.out and a_reciever.out
		gcc threading.c -o a.out
	STEP 6: Execute the compiled Binary from the Terminal
		./a.out
		
10. IMPLEMENTATION OF SYNCHRONIZATION
*************************************

AIM: To write a c program to implement the concept of Synchronization using locks
PROCEDURE:
	STEP 1: Create a blank text file named synchronization.c and type in the following
		#include <pthread.h>
		#include <stdio.h>
		#include <unistd.h>

		void *fun1();
		void *fun2();

		int shared = 1;
		pthread_mutex_t lock;
	
		int main() {
		  pthread_mutex_init(&lock, NULL);
		  pthread_t thread1, thread2;
	  
		  pthread_create(&thread1, NULL, fun1, NULL);
		  pthread_create(&thread2, NULL, fun2, NULL);
	  
		  pthread_join(thread1, NULL);
		  pthread_join(thread2, NULL);
  
		  printf("Final value of Shared Variable; %d\n", shared);
		}

		void *fun1() {
		  int x;
	  
		  printf("[1] locking...\n");
		  pthread_mutex_lock(&lock);
		  printf("[1] locked\n");
  
		  x = shared;
		  printf("[1] X: %d\n", x);
		  x++;
		  printf("[1] X (local): %d\n", x);
  
		  sleep(1);
  
		  shared = x;
		  printf("[1] value updated to shared variable\n");
		  pthread_mutex_unlock(&lock);
		  printf("[1] unlocked...\n");
		}

		void *fun2() {
		  int y;
  
		  printf("[2] locking...\n");
		  pthread_mutex_lock(&lock);
		  printf("[2] locked\n");
  
		  y = shared;
		  printf("[2] Y: %d\n", y);
		  y++;
		  printf("[2] Y (local): %d\n", y);
	  
		  sleep(1);
  
		  shared = y;
		  printf("[2] value updated to shared variable\n");
		  pthread_mutex_unlock(&lock);
		  printf("[2] unlocked...\n");
		}
	STEP 2: Compile the created .c files with gcc compiler and store the compiled binary in a_sender.out and a_reciever.out
		gcc synchronization.c -o a.out
	STEP 6: Execute the compiled Binary from the Terminal
		./a.out
		
