1) LINUX COMMANDS
*****************

AIM: To study and execute Linux Commands
COMMANDS:
	1. man <command>
		used to display the help manual
	
	2. touch <filename>
		used to create an blank file named <filename>
	
	3. cat <filename>
		used to print contents of the file named <filename>
	
	4. mkdir <dirname>
		used to create a directory called <dirname>
	
	5. rm <filename>
		used to remove a file called <filename>
	
	6. rmdir <dirname>
		used to remove a directory called <dirname>
	
	7. pwd
		used to display the current working directory
		
	8. ls
		used to list all files and directories in current working directory
		
	9. ls <dirname>
		used to list all files and directories in <dirname> direectory
	
	10. cd <dirname>
		used to switch the current working directory to <dirname>
	
	11. cp <sourceFile> <destinationFile>
		used to copy the filecontents from <sourceFile> to <destinationFile>
	
	12. mv <sourceFile> <destinationFile>
		used to move the filecontents from <sourceFile> to <destinationFile>
		
	13. echo "" | bc
		used to perfrom basic calculations
		
	14. head <filename>
		prints first 10 lines from file <filename>
	
	15. tail <filename>
		prints last 10 lines from file <filename>
		
	16. wc <filename>
		prints the character, word and line count of the file <filename>
	
	17. rev <filename>
		reverses the content of the file <filename> line-by-line
	
	18. whoami
		prints the details of the current user
	
	19. echo ""
		prints the content inside the quotes
	
	20. date
		prints the current date and time

2. SHELL PROGRAMMING
********************

AIM: To develop a simple calculator
PROGRAM:
	#!/bin/bash

	read -p "Enter a Integer: " a
	read -p "Enter another Integer: " b
	
	echo "1. Addition"
	echo "2. Subraction"
	echo "3. Multiplication"
	echo "4. Division"
	echo "5. Modulus"
	read -p "Enter your choice: " ch

	case $ch in
	1)
		res=$(( a+b ))
		echo "A + B = $res";;
	2)
		res=$(( a-b ))
		echo "A - B = $res";;
	3)
		res=$(( a*b ))
		echo "A * B = $res";;
	4)
		res=$(( a/b ))
		echo "A / B = $res";;
	5)
		res=$(( a%b ))
		echo "A % B = $res";;
	esac
	
AIM: To develop a program for Pattern Generation
PROGRAM:
	#!/bin/bash

	echo "Welcome to Pattern Generator"
	echo "****************************"
	echo
	read -p "Enter number of lines: " n
	echo
	echo "1. Simple Triangle"
	echo "2. Simple Number Triangle"
	echo "3. Right Triangle"
	echo "4. Triangle"
	echo "5. Diamond"
	read -p "Enter your choice: " ch
	echo
	echo
	
	case $ch in
	1)
		for((i=0; i<n; i++)) do
			for((j=0; j<i; j++)) do
				echo -n "* "
			done
			echo
		done;;
	2)
		for((i=0; i<n; i++)) do
			for((j=0; j<i; j++)) do
				echo -n "$j "
			done
			echo
		done;;
	3)
		for((i=0; i<n; i++)) do
			for((j=n-i; j>0; j--)) do
				echo -n "  "
			done
			for((j=0; j<i; j++)) do
				echo -n "* "
			done
			echo
		done;;
	4)
		for((i=0; i<n; i++)) do
			for((j=n-i; j>0; j--)) do
				echo -n "  "
			done
			for((j=0; j<i; j++)) do
				echo -n "* "
			done
			for((j=0; j<i-1; j++)) do
				echo -n "* "
			done
			echo
		done;;
	5)
		for((i=0; i<n; i++)) do
			for((j=n-i; j>0; j--)) do
				echo -n "  "
			done
			for((j=0; j<i; j++)) do
				echo -n "* "
			done
			for((j=0; j<i-1; j++)) do
				echo -n "* "
			done		
			echo
		done
		for((i=n-2; i>0; i--)) do
			for((j=n-i; j>0; j--)) do
				echo -n "  "
			done
			for((j=0; j<i; j++)) do
				echo -n "* "
			done
			for((j=0; j<i-1; j++)) do
				echo -n "* "
			done
			echo
		done;;
	esac


AIM: To develop a program to Generate Fibonacci Series
Program:
	#!/bin/bash
	
	read -p "Enter an Integer: " n
	
	a=0
	b=1
	echo -n "Fibonacci Series: "
	for((i=0; i<n; i++)) do
		echo -n "$a "
		c=$((a+b))
		a=$b
		b=$c
	done
	echo


3. FORK SYSTEM CALL
*******************

AIM: To create a new child process using fork system call
PROCEDURE:
	STEP 1:	Create a blank text file named fork.c and type in the following
		#include <stdio.h>
		#include <unistd.h>
		
		int main() {
			pid_t pid = fork();
			
			if(pid < 0) {
				printf("Fork failed\n");
				return 1;
			} 
			else if (pid == 0)
				printf("Hello from child process with PID: %d\n", getpid());
			else
				printf("Hello from parent process with PID: %d\n", getpid());
			return 0;
		}
	STEP 2: Compile the created .c file with gcc compiler and store the compiled binary into a.out
		gcc fork.c -o a.out
	STEP 3: Execute the compiled Binary from the Terminal
		./a.out

4. WAIT SYSTEM CALL
*******************

AIM: To block a parent until child completes using wait system call
PROCEDURE:
	STEP 1: Create a blank text file calles wait.c and type in the following
		#include <stdio.h>
		#include <unistd.h>
		#include <sys/wait.h>
	
		int main() {
	  	pid_t pid = fork();
	  
		  if(pid < 0) {
		    printf("Fork Failed");
		    return 1;
		  }
		  else if(pid == 0) {
		    printf("Child with Odd Numbers: ");
		    for(int i = 1; i < 10; i=i+2)
		      printf("%d ", i);
		    printf("Child ends\n");
		  }
		  else {
		    wait(NULL);
		    printf("Parent with Even Numbers: ");
		    for(int i = 0; i < 10; i=i+2)
		      printf("%d ", i);
		    printf("Parent ends\n");
		  }
		  return 0;
		}
	STEP 2: Compile the created .c file with gcc compiler and store the compiled binary in a.out
		gcc wait.c -o a.out
	STEP 3: Execute the compiled Binary from the Terminal
		./a.out

5. EXECL SYSTEM CALL
*******************

AIM: To load an executable program in a child process using execl system call
PROCEDURE:
	STEP 1: Create a blank text file calles execl.c and type in the following
		#include <stdio.h>
		#include <unistd.h>
		#include <sys/wait.h>

		int main() {
		  pid_t pid = fork();
  
		  if(pid < 0) {
    		printf("Fork Failed\n");
		    return 1;
  		}
  		else if(pid == 0) {
    		printf("Child Process: ");
    		execl("/bin/date", "date", NULL);
    		return 0;
  		}
  		else {
    		wait(NULL);
    		printf("Child Terminated\n");
    		return 0;
  		}
		}
	STEP 2: Compile the created .c file with gcc compiler and store the compiled binary in a.out
		gcc execl.c -o a.out
	STEP 3: Execute the compiled Binary from the Terminal
		./a.out

6. STAT SYSTEM CALL
*******************

AIM: To display file status using stat system call
PROCEDURE:
	STEP 1: Create a blank text file calles stat.c and type in the following
		#include <stdio.h>
		#include <unistd.h>
		#include <sys/stat.h>
		#include <time.h>
		#include <stdlib.h>
		#include <string.h>
		#include <errno.h>

		int main(int argc, char *argv[]) {
    	struct stat file;

	    if (argc != 2) {
        printf("Usage: ./a.out <filename>\n");
        return -1;
	    }

	    if (stat(argv[1], &file) == -1) {
        perror("Error getting file info");
        return -1;
	    }

	    printf("User ID: %d\n", file.st_uid);
	    printf("Group ID: %d\n", file.st_gid);
	    printf("Block Size: %ld\n", file.st_blksize);
	    printf("Blocks Allocated: %ld\n", file.st_blocks);
	    printf("Inode No.: %lu\n", file.st_ino);
	    printf("Last Accessed: %s", ctime(&file.st_atime));
	    printf("Last Modified: %s", ctime(&file.st_mtime));
	    printf("File Size: %ld bytes\n", file.st_size);
	    printf("No. of Links: %ld\n", file.st_nlink);
	
	    // Permissions
	    printf("Permissions: ");
	    printf((S_ISDIR(file.st_mode)) ? "d" : "-");
	    printf((file.st_mode & S_IRUSR) ? "r" : "-");
	    printf((file.st_mode & S_IWUSR) ? "w" : "-");
	    printf((file.st_mode & S_IXUSR) ? "x" : "-");
	    printf((file.st_mode & S_IRGRP) ? "r" : "-");
	    printf((file.st_mode & S_IWGRP) ? "w" : "-");
	    printf((file.st_mode & S_IXGRP) ? "x" : "-");
	    printf((file.st_mode & S_IROTH) ? "r" : "-");
	    printf((file.st_mode & S_IWOTH) ? "w" : "-");
	    printf((file.st_mode & S_IXOTH) ? "x" : "-");
	    printf("\n");
	
	    // File type
	    if (S_ISREG(file.st_mode))
	        printf("File Type: Regular File\n");
	    else if (S_ISDIR(file.st_mode))
	        printf("File Type: Directory\n");
	    else
	        printf("File Type: Other\n");
	
	    return 0;
		}
	STEP 2: Compile the created .c file with gcc compiler and store the compiled binary in a.out
		gcc stat.c -o a.out
	STEP 3: Execute the compiled Binary from the Terminal
		./a.out
		
7. INTERPROCESS COMMUNICATION
*****************************

AIM: To Implement IPC using popen() and pclose()
PROCEDURE:
	STEP 1: Create a blank text file calles IPC_1.c and type in the following
		#include <stdio.h>
		#include <string.h>

		int main() {
  		FILE *rd;
  		char buffer[50];
		  sprintf(buffer, "name first");

  		rd = popen("wc -c", "w");
  		if (rd == NULL) {
    		perror("popen failed");
    		return 1;
  		}

		  fwrite(buffer, sizeof(char), strlen(buffer), rd);
  		pclose(rd);

		  return 0;
		}
	STEP 2: Compile the created .c file with gcc compiler and store the compiled binary in a.out
		gcc IPC_1.c -o a.out
	STEP 3: Execute the compiled Binary from the Terminal
		./a.out
		
		
AIM: To Implement IPC using pipe()
PROCEDURE:
	STEP 1: Create a blank text file calles IPC_2.c and type in the following
		#include <stdio.h>
		#include <unistd.h>
		#include <sys/types.h>
		#include <sys/wait.h>

		int main() {
  		int fd[2], n;
  		char buffer[100];
  		pid_t p;
  
		  pipe(fd);
		  p = fork();
	  
		  if (p < 0) {
		    printf("Fork failed\n");
		    return 1;
		  } 
		  else if (p > 0) {
		    printf("Parent passing value to child\n");
		    write(fd[1], "hello\n", 6);
		    close(fd[1]);
		    wait(NULL);
		  } 
		  else {
		    printf("Child receiving value from parent: ");
		    fflush(stdout);
		    close(fd[1]);
		    n = read(fd[0], buffer, 100);
		    write(1, buffer, n);
		  }
		  return 0;
		}
	STEP 2: Compile the created .c file with gcc compiler and store the compiled binary in a.out
		gcc IPC_2.c -o a.out
	STEP 3: Execute the compiled Binary from the Terminal
		./a.out
		
AIM: To Implement IPC using fifo pipe()
PROCEDURE:
	STEP 1: Create a blank text file calles IPC_sender.c and type in the following
		// sender.c
		#include <stdio.h>
		#include <fcntl.h>
		#include <unistd.h>
		#include <sys/stat.h>

		int main() {
		    const char *fifo = "/tmp/myfifo";
		    mkfifo(fifo, 0666); // Create the named pipe (only once)
		
		    int fd = open(fifo, O_WRONLY); // Open for writing
		    char message[] = "Hello from sender!\n";
		
		    write(fd, message, sizeof(message));
		    close(fd);

		    return 0;
		}
	STEP 2: Create another blank text file calles IPC_reciever.c and type in the following
		// receiver.c
		#include <stdio.h>
		#include <fcntl.h>
		#include <unistd.h>
		#include <sys/stat.h>

		int main() {
		    const char *fifo = "/tmp/myfifo";
		    mkfifo(fifo, 0666); // Create the named pipe (only once)

		    int fd = open(fifo, O_RDONLY); // Open for reading
		    char buffer[100];

		    read(fd, buffer, sizeof(buffer));
		    printf("Received: %s", buffer);
		    close(fd);

		    return 0;
		}
	STEP 3: Compile the created .c files with gcc compiler and store the compiled binary in a_sender.out and a_reciever.out
		gcc IPC_sender.c -o a_sender.out
		gcc IPC_reciever.c -o a_reciever.out
	STEP 4: Execute the compiled Binary from the Terminal
		./a_sender.out
		./a_reciever.out
		
8. CREATION OF ZOMBIE AND ORPHAN PROCESS
****************************************

AIM: To demonstrate the creation of Zombie and orphan process using C
PROCEDURE:
	STEP 1: Create a blank text file calles zombie.c and type in the following
		// zombie.c
		#include <stdio.h>
		#include <unistd.h>

		int main() {
		  pid_t t = fork();
		  
		  if (t < 0) {
		    printf("Fork failed");
		    return 1;
		  }
		  else if (t == 0) {
		    printf("Child having PID: %d\n", getpid());
		    return 0;
		  }
		  else {
		    printf("Parent having id %d\n", getpid());
		    sleep(5);
		  }
		}
	STEP 2: Compile the created .c files with gcc compiler and store the compiled binary in a_sender.out and a_reciever.out
		gcc zombie.c -o a.out
	STEP 3: Execute the compiled Binary from the Terminal
		./a.out
	STEP 4: Create another blank text file calles orphan.c and type in the following
		// orphan.c
		#include <stdio.h>
		#include <unistd.h>
		#include <sys/types.h>

		int main() {
		  pid_t pid = fork();
	  
		  if (pid < 0) {
		    printf("Fork Failed");
		    return 1;
		  }
		  else if (pid > 0) {
		    printf("I'm a Parent with PID: %d\t", getpid());
		    printf("My Child has a PID: %d\n", pid);
		  }
		  else {
		    sleep(5);
		    printf("I'm a Child with PID: %d\t", getpid());
		    printf("My Parent has PID: %d\n", getppid());
		  }
		  return 0;
		}
	STEP 5: Compile the created .c files with gcc compiler and store the compiled binary in a_sender.out and a_reciever.out
		gcc orphan.c -o a.out
	STEP 6: Execute the compiled Binary from the Terminal
		./a.out
		
9. IMPLEMENTATION OF THREADING
******************************

AIM: To write a c program to implement the concept of Threads
PROCEDURE:
	STEP 1: Create a blank text file named threading.c and type in the following
		#include <stdio.h>
		#include <unistd.h>
		#include <pthread.h>
		#include <stdlib.h>

		void *thread_function(void *args);
		int i, n, j;

		int main() {
    	char *m = "5";
    	pthread_t a;
    	void *result;

    	pthread_create(&a, NULL, thread_function, m);
    	pthread_join(a, &result);
    	printf("Thread created and joined\n");

    	for(j = 20; j < 25; j++) {
        printf("%d\t", j);
        sleep(1);
    	}

    	printf("\nThread returned %s\n", (char *)result);
    	return 0;
		}

		void *thread_function(void *args) {
    	int sum = 0;
    	n = atoi((char *)args);
    	for(i = 0; i < n; i++) {
        printf("%d\t", i);
        sleep(1);
    	}
    	printf("\n");
    	pthread_exit("Done");
		}
	STEP 2: Compile the created .c files with gcc compiler and store the compiled binary in a_sender.out and a_reciever.out
		gcc threading.c -o a.out
	STEP 3: Execute the compiled Binary from the Terminal
		./a.out
		
10. IMPLEMENTATION OF SYNCHRONIZATION
*************************************

AIM: To write a c program to implement the concept of Synchronization using locks
PROCEDURE:
	STEP 1: Create a blank text file named synchronization.c and type in the following
		#include <pthread.h>
		#include <stdio.h>
		#include <unistd.h>

		void *fun1();
		void *fun2();

		int shared = 1;
		pthread_mutex_t lock;
	
		int main() {
		  pthread_mutex_init(&lock, NULL);
		  pthread_t thread1, thread2;
	  
		  pthread_create(&thread1, NULL, fun1, NULL);
		  pthread_create(&thread2, NULL, fun2, NULL);
	  
		  pthread_join(thread1, NULL);
		  pthread_join(thread2, NULL);
  
		  printf("Final value of Shared Variable; %d\n", shared);
		}

		void *fun1() {
		  int x;
	  
		  printf("[1] locking...\n");
		  pthread_mutex_lock(&lock);
		  printf("[1] locked\n");
  
		  x = shared;
		  printf("[1] X: %d\n", x);
		  x++;
		  printf("[1] X (local): %d\n", x);
  
		  sleep(1);
  
		  shared = x;
		  printf("[1] value updated to shared variable\n");
		  pthread_mutex_unlock(&lock);
		  printf("[1] unlocked...\n");
		}

		void *fun2() {
		  int y;
  
		  printf("[2] locking...\n");
		  pthread_mutex_lock(&lock);
		  printf("[2] locked\n");
  
		  y = shared;
		  printf("[2] Y: %d\n", y);
		  y++;
		  printf("[2] Y (local): %d\n", y);
	  
		  sleep(1);
  
		  shared = y;
		  printf("[2] value updated to shared variable\n");
		  pthread_mutex_unlock(&lock);
		  printf("[2] unlocked...\n");
		}
	STEP 2: Compile the created .c files with gcc compiler and store the compiled binary in a_sender.out and a_reciever.out
		gcc synchronization.c -o a.out
	STEP 3: Execute the compiled Binary from the Terminal
		./a.out
		
11. IMPLEMENTATION OF FCFS SCHEDULING
*************************************

AIM: To write a c program to implement the concept of FCFS 
PROCEDURE:
	STEP 1: Create a blank text file named fcfs.c and type in the following
		#include <stdio.h>

		struct process {
    		int pid, at, bt, st, ft, wt, tat;
		} ps[10];

		int nj;

		void getinput();
		void fcfs();
		void disp();

		int main() {
	    printf("Enter the number of jobs: ");
  	  scanf("%d", &nj);
  	  getinput();
  	  fcfs();
  	  disp();
  	  return 0;
		}

		void getinput() {
    	for (int i = 0; i < nj; i++) {
        ps[i].pid = i + 1;
        printf("1Enter arrival time & burst time for job %d: ", i + 1);
        scanf("%d %d", &ps[i].at, &ps[i].bt);
    	}
		}

		void fcfs() {
	    struct process temp;

    	// Sort based on arrival time
    	for (int i = 0; i < nj - 1; i++) {
        for (int j = i + 1; j < nj; j++) {
          if (ps[i].at > ps[j].at) {
            temp = ps[i];
            ps[i] = ps[j];
            ps[j] = temp;
          }
        }
    	}

    	// Scheduling calculations
    	for (int i = 0; i < nj; i++) {
        if (i == 0) {
           ps[i].st = ps[i].at;
        } else {
           ps[i].st = (ps[i - 1].ft > ps[i].at) ? ps[i - 1].ft : ps[i].at;
        }
        ps[i].ft = ps[i].st + ps[i].bt;
        ps[i].wt = ps[i].st - ps[i].at;
        ps[i].tat = ps[i].ft - ps[i].at;
    	}
		}

		void disp() {
    	int total_wt = 0, total_tat = 0;
    	float avg_wt, avg_tat;

    	printf("\n\t\tMETHOD FCFS\n\n");
    	printf("ID\tARRIVAL\tBURST\tSTART\tFINISH\tWAIT\tTAT\n");

    	for (int i = 0; i < nj; i++) {
        printf("%d\t%d\t%d\t%d\t%d\t%d\t%d\n", ps[i].pid, ps[i].at, ps[i].bt, ps[i].st, ps[i].ft, ps[i].wt, ps[i].tat);
        total_wt += ps[i].wt;
        total_tat += ps[i].tat;
    	}

    	avg_wt = (float) total_wt / nj;
    	avg_tat = (float) total_tat / nj;

	    printf("\nAverage Waiting Time = %.2f", avg_wt);
	    printf("\nAverage Turnaround Time = %.2f\n", avg_tat);
		}
	STEP 2: Compile the created .c files with gcc compiler and store the compiled binary in a_sender.out and a_reciever.out
		gcc fcfs.c -o a.out
	STEP 3: Execute the compiled Binary from the Terminal
		./a.out

12. IMPLEMENTATION OF SJF SCHEDULING
************************************

AIM: To write a c program to implement the concept of SJF 
PROCEDURE:
	STEP 1: Create a blank text file named sjf.c and type in the following
		#include <stdio.h>

		struct process {
    	int p, bt, st, ft, wt, tat;
		} t, ps[10];

		int nj;

		void getinput();
		void SJFS();
		void disp();

		int main() {
    	printf("Enter No of jobs: ");
	    scanf("%d", &nj);
  	  getinput();
  	  SJFS();
  	  disp();
  	  return 0;
		}

		void getinput() {
    	for (int i = 0; i < nj; i++) {
        ps[i].p = i + 1;
        printf("Enter the Burst time of job %d: ", i + 1);
        scanf("%d", &ps[i].bt);
    	}
		}

		void SJFS() {
    	// Sort by Burst Time
    	for (int i = 0; i < nj - 1; i++) {
        for (int j = i + 1; j < nj; j++) {
          if (ps[i].bt > ps[j].bt) {
            t = ps[i];
            ps[i] = ps[j];
            ps[j] = t;
          }
        }
    	}

    	// Calculate start, finish, wait, turnaround time
    	for (int i = 0; i < nj; i++) {
        if (i == 0) {
          ps[i].st = 0;
  	    } else {
          ps[i].st = ps[i - 1].ft;
        }

        ps[i].ft = ps[i].st + ps[i].bt;
        ps[i].wt = ps[i].st;  // No arrival time considered
        ps[i].tat = ps[i].ft; // No arrival time considered
    	}
		}

		void disp() {
    	int total_wt = 0, total_tat = 0;
    	float avg_wt, avg_tat;

    	printf("\n\t\tMETHOD SJFS (NON-PREEMPTIVE)\n\n");
    	printf("ID\tBURST TIME\tSTART\tFINISH\tWAIT\tTAT\n");

    	for (int i = 0; i < nj; i++) {
        printf("%d\t%d\t\t%d\t%d\t%d\t%d\n", ps[i].p, ps[i].bt, ps[i].st, ps[i].ft, ps[i].wt, ps[i].tat);
        total_wt += ps[i].wt;
        total_tat += ps[i].tat;
    	}

    	avg_wt = (float)total_wt / nj;
    	avg_tat = (float)total_tat / nj;

    	printf("\nAverage Waiting Time = %.2f", avg_wt);
    	printf("\nAverage Turnaround Time = %.2f\n", avg_tat);
		}
	STEP 2: Compile the created .c files with gcc compiler and store the compiled binary in a_sender.out and a_reciever.out
		gcc sjf.c -o a.out
	STEP 3: Execute the compiled Binary from the Terminal
		./a.out


13. IMPLEMENTATION OF ROUND ROBIN SCHEDULING
********************************************

AIM: To write a c program to implement the concept of Round Robin Scheduling 
PROCEDURE:
	STEP 1: Create a blank text file named roundrobin.c and type in the following
		#include <stdio.h>

		void main() {
    	int p[30], bt[30], i, n, d;

    	printf("Enter the number of jobs: ");
    	scanf("%d", &n);

    	for (i = 0; i < n; i++) {
        printf("Enter the CPU burst time for process %d: ", i + 1);
        p[i] = i + 1;
        scanf("%d", &bt[i]);
    	}

    	d = n;

    	while (d != 0) {
        for (i = 0; i < n; i++) {
          if (p[i] != 0) {
            if (bt[i] > 5) {
            	printf("\nProcess %d is executed for 5 sec", p[i]);
              bt[i] = bt[i] - 5;
            } else {
              printf("\nProcess %d is executed for %d sec (Completed)", p[i], bt[i]);
              bt[i] = 0;
              p[i] = 0;
              d--;
            }
          }
        }
    	}
		}
	STEP 2: Compile the created .c files with gcc compiler and store the compiled binary in a_sender.out and a_reciever.out
		gcc roundrobin.c -o a.out
	STEP 3: Execute the compiled Binary from the Terminal
		./a.out

14. IMPLEMENTATION OF PRIORITY SCHEDULING
*****************************************

AIM: To write a c program to implement the concept of Round Robin Scheduling 
PROCEDURE:
	STEP 1: Create a blank text file named priority.c and type in the following
		#include <stdio.h>

		struct process {
	    int pid, pr, bt, stt, ft, wt;
		} t, ps[10] = {0};

		int nj, i, j;

		void getinput();
		void priority();
		void disp_state();
	
		void main() {
	    printf("Enter the number of Jobs : ");
	    scanf("%d", &nj);
	    getinput();
	    priority();
	    disp_state();
		}
	
		void getinput() {
	    for (i = 0; i < nj; i++) {
        ps[i].pid = i;
        printf("\nEnter the burst time and priority of job %d: ", i + 1);
        scanf("%d %d", &ps[i].bt, &ps[i].pr);
	    }
		}

		void priority() {
	    // Sort based on priority (lower value = higher priority)
	    for (i = 0; i < nj - 1; i++) {
        for (j = i + 1; j < nj; j++) {
          if (ps[i].pr > ps[j].pr) {
            t = ps[i];
            ps[i] = ps[j];
            ps[j] = t;
          }
        }
    	}

	    // Calculate start time, finish time, and waiting time
	    for (i = 0; i < nj; i++) {
        if (i == 0) {
          ps[i].stt = 0;
          ps[i].wt = 0;
        } else {
          ps[i].stt = ps[i - 1].ft;
          ps[i].wt = ps[i].stt;
        }
        ps[i].ft = ps[i].stt + ps[i].bt;
    	}
		}

		void disp_state() {
    	int tw = 0, tt = 0;
    	float aw, ata;

    	printf("\n\tMETHOD PRIORITY SCHEDULING\n\n");
    	printf("ID\tPRIORITY\tBURST TIME\tSTART\tFINISH\tWAIT\n");
	
    	for (i = 0; i < nj; i++) {
        printf("%d\t%d\t\t%d\t\t%d\t%d\t%d\n", ps[i].pid + 1, ps[i].pr, ps[i].bt, ps[i].stt, ps[i].ft, ps[i].wt);
        tw += ps[i].wt;
        tt += ps[i].ft;
    	}

    	aw = (float)tw / nj;
    	ata = (float)tt / nj;
    	printf("\nAVG WAITING TIME = %f", aw);
    	printf("\nAVG TURN AROUND TIME = %f\n", ata);
		}
	STEP 2: Compile the created .c files with gcc compiler and store the compiled binary in a_sender.out and a_reciever.out
		gcc priority.c -o a.out
	STEP 3: Execute the compiled Binary from the Terminal
		./a.out
		
15. IMPLEMENTATION OF PRODUCER-CONSUMER PROBLEM
***********************************************

AIM: To write a c program to implement the concept of Producer-Consumer Problem using Semaphores 
PROCEDURE:
	STEP 1: Create a blank text file named producer-consumer.c and type in the following
		#include <stdio.h>
		#include <stdlib.h>

		int full = 0, empty = 5, mutex = 1;
		int buffer[5], in = 0, out = 0;

		void wait(int *s) {
    	while (*s <= 0);
	    (*s)--;
		}

		void signal(int *s) {
	    (*s)++;
		}

		void producer() {
	    int nextp;
	    printf("\nProducer\n");
	    wait(&empty);
	    wait(&mutex);
	    nextp = rand() % 10 + 1;
	    buffer[in] = nextp;
	    printf("Produced item: %d\n", nextp);
	    in = (in + 1) % 5;
	    signal(&mutex);
	    signal(&full);
	    printf("Full = %d\tEmpty = %d\n", full, empty);
		}
	
		void consumer() {
	    int nextc;
	    printf("\nConsumer\n");
	    wait(&full);
	    wait(&mutex);
	    nextc = buffer[out];
	    printf("Consumed item: %d\n", nextc);
	    out = (out + 1) % 5;
	    signal(&mutex);
	    signal(&empty);
	    printf("Full = %d\tEmpty = %d\n", full, empty);
		}

		void main() {
	    int choice;
	    while (1) {
        printf("\n1. Produce\n2. Consume\n3. Both\n4. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);
        switch (choice) {
          case 1:
            if (empty == 0)
              printf("Producer has to wait (Buffer Full)\n");
            else
              producer();
            break;
          case 2:
            if (full == 0)
              printf("Consumer has to wait (Buffer Empty)\n");
            else
              consumer();
            break;
          case 3:
            if (empty == 0)
              printf("Producer has to wait (Buffer Full)\n");
            else
              producer();

            if (full == 0)
              printf("Consumer has to wait (Buffer Empty)\n");
            else
              consumer();
            break;
          case 4:
            exit(0);
          default:
            printf("Invalid choice!\n");
        }
    	}
		}
	STEP 2: Compile the created .c files with gcc compiler and store the compiled binary in a_sender.out and a_reciever.out
		gcc producer-consumer.c -o a.out
	STEP 3: Execute the compiled Binary from the Terminal
		./a.out
		
16. IMPLEMENTATION OF DINING-PHILOSOPHERS PROBLEM
*************************************************

AIM: To write a c program to implement the concept of Dining Philosophers Problem using Semaphores 
PROCEDURE:
	STEP 1: Create a blank text file named dining-philosophers.c and type in the following
		#include <stdio.h>
		#include <stdlib.h>
		#include <pthread.h>
		#include <semaphore.h>
		#include <unistd.h>

		sem_t chopstick[5];

		void *philos(void *);
		void eat(int);

		int main() {
	    int i, n[5];
	    pthread_t T[5];

	    for (i = 0; i < 5; i++)
        sem_init(&chopstick[i], 0, 1);

	    for (i = 0; i < 5; i++) {
        n[i] = i;
        pthread_create(&T[i], NULL, philos, (void *)&n[i]);
	    }

	    for (i = 0; i < 5; i++)
        pthread_join(T[i], NULL);

	    return 0;
		}

		void *philos(void *n) {
	    int ph = *(int *)n;

	    printf("Philosopher %d wants to eat\n", ph);
	    printf("Philosopher %d tries to pick up left chopstick\n", ph);
	    sem_wait(&chopstick[ph]);
	    printf("Philosopher %d picked up left chopstick\n", ph);

	    printf("Philosopher %d tries to pick up right chopstick\n", ph);
	    sem_wait(&chopstick[(ph + 1) % 5]);
	    printf("Philosopher %d picked up right chopstick\n", ph);

	    eat(ph);
	    sleep(2);

	    printf("Philosopher %d has finished eating\n", ph);

	    sem_post(&chopstick[(ph + 1) % 5]);
	    printf("Philosopher %d put down right chopstick\n", ph);

	    sem_post(&chopstick[ph]);
	    printf("Philosopher %d put down left chopstick\n", ph);

	    pthread_exit(NULL);
		}

		void eat(int ph) {
	    printf("Philosopher %d begins to eat\n", ph);
		}
	STEP 2: Compile the created .c files with gcc compiler and store the compiled binary in a_sender.out and a_reciever.out
		gcc dining-philosophers.c -o a.out
	STEP 3: Execute the compiled Binary from the Terminal
		./a.out
		
16. IMPLEMENTATION OF BANKER'S ALGORITHM
****************************************

AIM: To write a c program to implement the concept of Banker's Algorithm using Semaphores 
PROCEDURE:
	STEP 1: Create a blank text file named bankers-algorithm.c and type in the following
		#include <stdio.h>

		int main() {
	    int k = 0, a = 0, b = 0;
	    int instance[5], op[10], availability[5];
	    int allocated[10][5], need[10][5], MAX[10][5];
	    int process, P[10], no_of_resources, cnt = 0;
	    int i, j;
	
	    printf("\nEnter the number of resources: ");
	    scanf("%d", &no_of_resources);
	
	    printf("\nEnter the max instances of each resource\n");
	    for (i = 0; i < no_of_resources; i++) {
        availability[i] = 0;
        printf("%c = ", (i + 97));  // a, b, c,...
        scanf("%d", &instance[i]);
	    }

	    printf("\nEnter the number of processes: ");
	    scanf("%d", &process);

	    printf("\nEnter the Allocation matrix:\n");
	    for (i = 0; i < no_of_resources; i++)
        printf(" %c", (i + 97));
		  printf("\n");

    	for (i = 0; i < process; i++) {
        P[i] = i;
        printf("P[%d] ", P[i]);
        for (j = 0; j < no_of_resources; j++) {
            scanf("%d", &allocated[i][j]);
            availability[j] += allocated[i][j];
        }
    	}

    	printf("\nEnter the MAX matrix:\n");
    	for (i = 0; i < no_of_resources; i++) {
        printf(" %c", (i + 97));
        availability[i] = instance[i] - availability[i];  // Calculate initial available
    	}
    	printf("\n");

    	for (i = 0; i < process; i++) {
        printf("P[%d] ", i);
        for (j = 0; j < no_of_resources; j++) {
          scanf("%d", &MAX[i][j]);
        }
    	}

	    // Safety Algorithm
			A:
	    	a = -1;
    		for (i = 0; i < process; i++) {
      	  cnt = 0;
      	  b = P[i];
      	  for (j = 0; j < no_of_resources; j++) {
      	    need[b][j] = MAX[b][j] - allocated[b][j];
      	    if (need[b][j] <= availability[j])
      	      cnt++;
      	  }
	
      	  if (cnt == no_of_resources) {
      	    op[k++] = P[i];
      	    for (j = 0; j < no_of_resources; j++)
      	      availability[j] += allocated[b][j];
      	  } else {
      	    P[++a] = P[i];
      	  }
    		}

	    if (a != -1) {
        process = a + 1;
        goto A;
	    }

	    printf("\nSafe Sequence: < ");
	    for (i = 0; i < k; i++)
        printf("P[%d] ", op[i]);
	    printf(">\n");

	    return 0;
		}
	STEP 2: Compile the created .c files with gcc compiler and store the compiled binary in a_sender.out and a_reciever.out
		gcc bankers-algorithm.c -o a.out
	STEP 3: Execute the compiled Binary from the Terminal
		./a.out
		
17. LINUX KERNEL CONFIGURATION, COMPILATION, AND BOOTING
********************************************************

AIM: To demonstrate Linux Kernel Configuration, Compilation, and Rebooting from the newly compiled Kernel
PROCEDURE:
	STEP 1: Get the latest Linux Kernel source code from the official website
	STEP 2: Navigate to the Downloaded file's directory in Terminal by using cd commands
	STEP 3: Extract the downloaded tar file by using the commands
						unxz -v linux-a.b.c.tar.xz
	STEP 4: Verify the Linux Kernel tartball
						curl https://cdn.kernel.org/pub/linux/va.x/linux-a.b.c.tar.sign
						gpg --verify linux-a.b.c.tar.sign
	STEP 5: From the above output, copy the RSA Key, which looks like this xxxxxxxxxxxxxxxx, with letters and numbers
						gpg --recv-keys xxxxxxxxxxxxxxxx
	STEP 6: Now verify the key again
						gpg --verify linux-a.b.c.tar.sign
	STEP 7: If you don't get BAD SIGNATURE output, extract the file
						tar xvf linux-a.b.c.tar
	STEP 8: Navigate into the extracted folder
						cd linux-a.b.c
	STEP 8: Copy the existing config file using the command
						cp -v /boot/config-$(uname -r).config
	STEP 9: Install required packages and Configure it by using the public script
						bash <(curl -s https://raw.githubusercontent.com/the-asherbrook-06/linux/main/linux-compilers.sh)
	STEP 10: Reboot the Linux System and boot into new Kernel
						sudo reboot now

18. SIMULATION OF FILE ALLOCATION STRATEGIES - LINKED FILE ALLOCATION
*********************************************************************
AIM: To implement file allocation technique using linked file allocation
PROCEDURE:
	STEP 1: Create a blank text file named linked-file-alloc.c and type in the following
		#include <stdio.h>
		#include <stdlib.h>

		int main() {
	    int f[50], i, st, j, len, c;

	    for(i = 0; i < 50; i++)
        f[i] = 0;

	    do {
        printf("\nEnter the starting block and length of the file: ");
        scanf("%d%d", &st, &len);

        if(st + len > 50) {
          printf("File exceeds disk size. Try again.\n");
          continue;
        }

        int allocated = 1;
        for(j = st; j < (st + len); j++) {
          if(f[j] == 0) {
            f[j] = 1;
            printf("%d -> %d\n", j, f[j]);
          } else {
            printf("Block %d already allocated!\n", j);
            allocated = 0;
            break;
          }
        }

        if(allocated)
          printf("File successfully allocated to disk.\n");

        printf("\nDo you want to enter more files? (Yes: 1 / No: 0): ");
        scanf("%d", &c);

    	} while(c == 1);

    	printf("Exiting program.\n");
    	return 0;
		}
	STEP 2: Compile the created .c files with gcc compiler and store the compiled binary in a_sender.out and a_reciever.out
		gcc linked-file-alloc.c -o a.out
	STEP 3: Execute the compiled Binary from the Terminal
		./a.out

19. SIMULATION OF FILE ALLOCATION STRATEGIES - INDEXED FILE ALLOCATION
**********************************************************************
AIM: To implement file allocation technique using linked file allocation
PROCEDURE:
	STEP 1: Create a blank text file named indexed-file-alloc.c and type in the following
		#include <stdio.h>
		#include <stdlib.h>

		int main() {
	    int f[50], i, k, j, inde[50], n, c, p;

	    // Initialize all blocks as free
	    for(i = 0; i < 50; i++)
        f[i] = 0;

	    while(1) {
        printf("\nEnter index block: ");
        scanf("%d", &p);

        if(f[p] == 0) {
          f[p] = 1;
          printf("Enter number of blocks for the file: ");
          scanf("%d", &n);

          printf("Enter the blocks:\n");
          for(i = 0; i < n; i++)
            scanf("%d", &inde[i]);

          // Check if all blocks are free
          int allocated = 1;
          for(i = 0; i < n; i++) {
            if(f[inde[i]] == 1) {
              printf("Block %d already allocated. Try again.\n", inde[i]);
              allocated = 0;
              break;
            }
          }

          if(allocated) {
            for(j = 0; j < n; j++)
              f[inde[j]] = 1;

            printf("\nFile allocated using indexed allocation.");
            printf("\nIndex block: %d", p);
            printf("\nBlocks allocated:");
            for(k = 0; k < n; k++)
              printf("\n %d -> %d", p, inde[k]);
          }
        } else {
          printf("Block %d is already allocated. Try another.\n", p);
        }

      	printf("\n\nDo you want to enter more files? (Yes: 1 / No: 0): ");
        scanf("%d", &c);
        if(c == 0)
          break;
    	}
    	printf("Exiting program.\n");
    	return 0;
		}
	STEP 2: Compile the created .c files with gcc compiler and store the compiled binary in a_sender.out and a_reciever.out
		gcc indexed-file-alloc.c -o a.out
	STEP 3: Execute the compiled Binary from the Terminal
		./a.out

20. SIMULATION OF FILE ALLOCATION STRATEGIES - SEQUENTIAL FILE ALLOCATION
*************************************************************************
AIM: To implement file allocation technique using sequential file allocation
PROCEDURE:
	STEP 1: Create a blank text file named sequential-file-alloc.c and type in the following
		#include <stdio.h>
		#include <stdlib.h>

		int main() {
    	int f[50], i, st, j, len, c, k;

    	// Initialize all blocks as free
	    for(i = 0; i < 50; i++)
        f[i] = 0;

  	  do {
        printf("\nEnter the starting block and length of the file: ");
        scanf("%d%d", &st, &len);

        if (st < 0 || st + len > 50) {
          printf("Invalid block range. Try again.\n");
          continue;
        }

        int allocated = 1;
        for(j = st; j < (st + len); j++) {
          if(f[j] == 1) {
            printf("Block %d is already allocated. Cannot allocate file.\n", j);
            allocated = 0;
            break;
          }
        }

        if (allocated) {
          for(j = st; j < (st + len); j++) {
            f[j] = 1;
            printf("%d -> %d\n", j, f[j]);
          }
          printf("File successfully allocated.\n");
	      }

        printf("\nDo you want to enter more files? (Yes: 1 / No: 0): ");
        scanf("%d", &c);
    	} while(c == 1);
    	printf("Exiting program.\n");
    	return 0;
		}
	STEP 2: Compile the created .c files with gcc compiler and store the compiled binary in a_sender.out and a_reciever.out
		gcc sequential-file-alloc.c -o a.out
	STEP 3: Execute the compiled Binary from the Terminal
		./a.out
